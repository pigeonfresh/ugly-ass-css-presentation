# Dynamic Data

Muban is designed to work with HTML that is fully generated by the server, where it only provides
the `js` and `css` to make the website look and work the way it should. The big downside is that
it's not possible to work with data-binding template engines that frameworks like Vue, React and
Angular do, because they have control over the HTML.

This means we create (interactive) components by passing the HTML element, and the component should
use querySelectors and other DOM APIs to read from and write to the DOM. We have added Knockout to
Muban to allow you to set up data-bindings from within JavaScript, but that only gets you so far.

When having to deal with dynamic data fetched from JavaScript, or rendered lists that need to be
sorted of filtered client-side, we need to think of something else. Below are some common scenarios
and how you can deal with them.

Please have a look at the [examples](./dynamic-data-examples.md)

## Different types of dynamic data

In this case, dynamic data is everything that is not rendered as visible HTML. There are different
ways to pass down additional data to the browser so it can be used by JavaScript upon user
interaction.

* data-attributes
* embedded json
* http requests (fetch)

### data-attributes

If you don't have much additional data, it can be rendered within the data-attributes on the
component DOM node.

**Passing additional color presets:**

```html
<div data-component="foo" data-colors="#CC9933,#22AA88,#FF8822"></div>
```
```js
const colors = this.element.dataset.colors.split(',');
```

**Structured data:**

```html
<div data-component="foo" data-json="{ &quot;users&quot;: [ { &quot;id&quot;: 0, &quot;name&quot;: &quot;Adam Carter&quot;, &quot;work&quot;: &quot;Unilogic&quot;, &quot;email&quot;: &quot;adam.carter@unilogic.com&quot;, &quot;dob&quot;: &quot;1978&quot;, &quot;address&quot;: &quot;83 Warner Street&quot;, &quot;city&quot;: &quot;Boston&quot;, &quot;optedin&quot;: true }, { &quot;id&quot;: 1, &quot;name&quot;: &quot;Leanne Brier&quot;, &quot;work&quot;: &quot;Connic&quot;, &quot;email&quot;: &quot;leanne.brier@connic.org&quot;, &quot;dob&quot;: &quot;13/05/1987&quot;, &quot;address&quot;: &quot;9 Coleman Avenue&quot;, &quot;city&quot;: &quot;Toronto&quot;, &quot;optedin&quot;: false } ], &quot;images&quot;: [ &quot;img0.png&quot;, &quot;img1.png&quot;, &quot;img2.png&quot; ], &quot;coordinates&quot;: { &quot;x&quot;: 35.12, &quot;y&quot;: -21.49 }, &quot;price&quot;: &quot;$59,395&quot; }"></div>
```
```js
const data = JSON.parse(this.element.dataset.json);
```

Just be sure to properly encode the content, especially when outputting user generated content.

When the data becomes too big to put in data-attributes, it might be better to embed them in the
document.

### Embedded json

When needing quite a big payload on your page, you can embed it in a non-JS script tag, and parse
it with JS afterwards.

```html
<div data-component="foo" data-colors="#CC9933,#22AA88,#FF8822">
  <script type="text/json">
    {
      "users": [
        {
          "id": 0,
          "name": "Adam Carter",
          "email": "adam.carter@unilogic.com",
          "dob": "1978",
          "address": "83 Warner Street",
          "city": "Boston"
        },
        {
          "id": 1,
          "name": "Leanne Brier",
          "email": "leanne.brier@connic.org",
          "dob": "13/05/1987",
          "address": "9 Coleman Avenue",
          "city": "Toronto"
        }
      ],
      "images": [
        "img0.png",
        "img1.png",
        "img2.png"
      ],
      "coordinates": {
        "x": 35.12,
        "y": -21.49
      },
      "price": "$59,395"
    }
  </script>
  <div class="content">
    foobar
  </div>
</div>
```
```js
const data = JSON.parse(this.getElement<HTMLScriptElement>('script[type="text/json"]').innerHTML);
```

### fetch()

If the data is too big, or too dynamic, and the backend has an API in place, we can also get more
data that way.

For basic XHR calls, you should use the
[Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch). To support
older browsers (IE), you should include the [fetch polyfill](https://github.com/github/fetch).

Install:

```
yarn add whatwg-fetch
```

Import in the file in `bootstrap.dev.js` and `bootstrap.dist.js`:

```
import 'whatwg-fetch';
```

##### Getting HTML

```
fetch('/users.html')
  .then(response => response.text())
  .then(body => {
    document.body.innerHTML = body;
  });
```

##### Getting JSON

```
fetch('/users.json')
  .then(response => response.json())
  .then(json => {
    console.log('parsed json', json);
  }).catch(ex => {
    console.error('parsing failed', ex);
  });
```

##### Post form

```
var form = document.querySelector('form')

fetch('/users', {
  method: 'POST',
  body: new FormData(form),
});
```

##### Post JSON

```
fetch('/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'Hubot',
    login: 'hubot',
  }),
});
```

##### File Upload

```
const input = document.querySelector('input[type="file"]')

const data = new FormData()
data.append('file', input.files[0]); // file
data.append('user', 'hubot'); // other data

fetch('/avatars', {
  method: 'POST',
  body: data
})
```

### Axios

If you need more features, you could use [Axios](https://github.com/axios/axios). It's a wrapper
around `fetch`, but with more configuration options.

## Dynamic Templates

Getting the dynamic data is just the first part, we also need to display the data on the screen.

There are several ways to get this done, and choosing one depends on the complexity of the data and
the template itself. 

The following scenarios can occur:

* moving around existing items in the DOM
* toggling visibility of different parts of the DOM 
* updating an existing view / item
* adding new items based on an existing template
* adding new items without an existing template

### Moving around existing items in the DOM

This could happen when you render all items on the server, and having a client-side sort/filter.

In this case you could simply pull all item DOM nodes from the container, extract the needed
information to apply a sort/filter, and add the resulting items back in the DOM. 

### Toggling visibility of different parts of the DOM

This could happen when you have multiple views (e.g. a TabBar) that are all rendered on the server,
but in the client you only show the 'active' view, and hide the other ones.

### Updating an existing view / item

This could happen when you have a detail view, and you want to show a different variant without
reloading the page.

### Adding new items based on an existing template

This could happen when you have a 'Load More' button to do client-side pagination.

An existing template could be one of a few things:

* An existing DOM element of the item, we can then clone the element and update the content with
  setting `textContent` or `innerHTML`.
* Rendering a 'template' element (display:none, without any content), and use that the same way
  as above.
* Reusing the `.hbs` template in the JS bundle, by calling the `renderItem`/`renderItems` methods
  from `muban-core`.
* Creating a `knockout` template and render those. Normally the hbs templates are preferred, but if
  you have additional logic to execute, this will be a nice solution. Or if you never render any
  template on the server, and already include the knockout lib in your project, this is also fine.
  
The main thing you want to minimize, is duplicate templates. So if you already rendering something
on the server, you want that to be the source of truth, without duplicating the template in the JS
bundle. That's why reusing `.hbs` is normally better than knockout, you only have to maintain a
single template (still keep them sync between server and client though).

### Adding new items without an existing template

This is similar to the case above, but now we're not sure we have an existing item in the DOM we
could clone. This could be conditionally (depending on which page you're on), or always (you never
render the template on the server at all).
